{"ast":null,"code":"import TLError from \"../core/TLError\";\nimport { fetchCSV } from '../core/CSV';\nimport { trim, isEmptyObject, mergeData, trace } from \"../core/Util\";\n/**\n * Given a Google Sheets URL or a bare spreadsheet key, return a URL expected\n * to retrieve a CSV file, assuming the Sheets doc has been \"published to the web\".\n * No checking for the actual availability is done.\n * @param {string} url_or_key \n */\n\nexport function makeGoogleCSVURL(url_or_key) {\n  url_or_key = url_or_key.trim();\n\n  if (url_or_key.match(/^[a-zA-Z0-9-_]+$/)) {\n    // key pattern from https://developers.google.com/sheets/api/guides/concepts#spreadsheet_id\n    return `https://docs.google.com/spreadsheets/d/${url_or_key}/pub?output=csv`;\n  }\n\n  if (url_or_key.startsWith('https://docs.google.com/spreadsheets/')) {\n    if (url_or_key.match(/\\/pub\\?output=csv$/)) return url_or_key;\n    let parsed = new URL(url_or_key);\n    let params = new URLSearchParams(parsed.search);\n    params.set('output', 'csv');\n\n    if (params.get('gid')) {\n      params.set('single', 'true');\n    }\n\n    parsed.search = `?${params.toString()}`;\n    let base_path = parsed.pathname.substr(0, parsed.pathname.lastIndexOf('/'));\n    parsed.pathname = `${base_path}/pub`;\n    return parsed.toString();\n  }\n\n  throw new TLError('invalid_url_err', url_or_key);\n}\n/**\n * Given a Google Sheets URL (or mere document ID), read the data and return\n * a Timeline JSON file suitable for instantiating a timeline.\n * \n * @param {string} url \n */\n\nexport async function readGoogleAsCSV(url, sheets_proxy) {\n  let rows = [];\n  url = makeGoogleCSVURL(url);\n  let error = null;\n  await fetchCSV({\n    url: `${sheets_proxy}${url}`\n  }).then(d => {\n    rows = d;\n  }).catch(error_json => {\n    if (error_json.proxy_err_code == 'response_not_csv') {// throw new TLError('Timeline could not read the data for your timeline. Make sure you have published it to the web.')\n    } // throw new TLError(error_json.message)\n\n  });\n  let timeline_config = {\n    'events': [],\n    'errors': [],\n    'warnings': [],\n    'eras': []\n  };\n  rows.forEach((row, i) => {\n    try {\n      if (!isEmptyObject(row)) {\n        let event = extractEventFromCSVObject(row);\n        handleRow(event, timeline_config);\n      }\n    } catch (e) {\n      if (e.constructor == TLError) {\n        timeline_config.errors.push(e);\n      } else {\n        if (e.message) {\n          e = e.message;\n        }\n\n        let label = row['Headline'] || i;\n        timeline_config.errors.push(e + `[${label}]`);\n      }\n    }\n  });\n  console.log(timeline_config);\n  return timeline_config;\n}\n\nfunction handleRow(event, timeline_config) {\n  var row_type = 'event';\n\n  if (typeof event.type != 'undefined') {\n    row_type = event.type;\n    delete event.type;\n  }\n\n  if (row_type == 'title') {\n    if (!timeline_config.title) {\n      timeline_config.title = event;\n    } else {\n      timeline_config.warnings.push(\"Multiple title slides detected.\");\n      timeline_config.events.push(event);\n    }\n  } else if (row_type == 'era') {\n    timeline_config.eras.push(event);\n  } else {\n    timeline_config.events.push(event);\n  }\n}\n\nfunction extractEventFromCSVObject(orig_row) {\n  let row = {};\n  Object.keys(orig_row).forEach(k => {\n    row[k] = trim(orig_row[k]); // get rid of white-space and reduce all-blank cells to empty strings\n  });\n  var d = {\n    media: {\n      caption: row['Media Caption'] || '',\n      credit: row['Media Credit'] || '',\n      url: row['Media'] || '',\n      thumbnail: row['Media Thumbnail'] || ''\n    },\n    text: {\n      headline: row['Headline'] || '',\n      text: row['Text'] || ''\n    },\n    display_date: row['Display Date'] || '',\n    // only in v3 but no problem\n    group: row['Group'] || row['Tag'] || '',\n    // small diff between v1 and v3 sheets\n    background: interpretBackground(row['Background']),\n    // only in v3 but no problem\n    type: row['Type'] || ''\n  };\n\n  if (Object.keys(row).includes('Start Date') || Object.keys(row).includes('End Date')) {\n    // V1 date handling\n    if (row['Start Date']) {\n      d.start_date = parseDate(row['Start Date']);\n    }\n\n    if (row['End Date']) {\n      d.end_date = parseDate(row['End Date']);\n    }\n  } else {\n    // V3 date handling\n    // every date must have at least a year to be valid.\n    if (row['Year']) {\n      d.start_date = {\n        year: clean_integer(row['Year']),\n        month: clean_integer(row['Month']) || '',\n        day: clean_integer(row['Day']) || ''\n      };\n    }\n\n    if (row['End Year']) {\n      d.end_date = {\n        year: clean_integer(row['End Year']) || '',\n        month: clean_integer(row['End Month']) || '',\n        day: clean_integer(row['End Day']) || ''\n      };\n    }\n\n    if (row['Time']) {\n      if (d.start_date) {\n        mergeData(d.start_date, parseTime(row['Time']));\n      } else {\n        throw new TLError(\"invalid_start_time_without_date\");\n      }\n    }\n\n    if (row['End Time']) {\n      if (d.end_date) {\n        mergeData(d.end_date, parseTime(row['End Time']));\n      } else {\n        throw new TLError(\"invalid_end_time_without_date\");\n      }\n    }\n\n    if (d.start_date && !validDateConfig(d.start_date)) {\n      throw new TLError(\"invalid_date_err\");\n    }\n\n    if (d.end_date && !validDateConfig(d.end_date)) {\n      throw new TLError(\"invalid_date_err\");\n    }\n  }\n\n  return d;\n}","map":{"version":3,"sources":["/Users/nanyang/AY20S2/CS9080/LookingGlass/lookingglass/src/core/Config.js"],"names":["TLError","fetchCSV","trim","isEmptyObject","mergeData","trace","makeGoogleCSVURL","url_or_key","match","startsWith","parsed","URL","params","URLSearchParams","search","set","get","toString","base_path","pathname","substr","lastIndexOf","readGoogleAsCSV","url","sheets_proxy","rows","error","then","d","catch","error_json","proxy_err_code","timeline_config","forEach","row","i","event","extractEventFromCSVObject","handleRow","e","constructor","errors","push","message","label","console","log","row_type","type","title","warnings","events","eras","orig_row","Object","keys","k","media","caption","credit","thumbnail","text","headline","display_date","group","background","interpretBackground","includes","start_date","parseDate","end_date","year","clean_integer","month","day","parseTime","validDateConfig"],"mappings":"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","sourcesContent":["import TLError from \"../core/TLError\"\nimport { fetchCSV } from '../core/CSV';\nimport { trim, isEmptyObject, mergeData, trace } from \"../core/Util\";\n\n\n\n/**\n * Given a Google Sheets URL or a bare spreadsheet key, return a URL expected\n * to retrieve a CSV file, assuming the Sheets doc has been \"published to the web\".\n * No checking for the actual availability is done.\n * @param {string} url_or_key \n */\nexport function makeGoogleCSVURL(url_or_key) {\n    url_or_key = url_or_key.trim()\n    if (url_or_key.match(/^[a-zA-Z0-9-_]+$/)) {\n        // key pattern from https://developers.google.com/sheets/api/guides/concepts#spreadsheet_id\n        return `https://docs.google.com/spreadsheets/d/${url_or_key}/pub?output=csv`\n    }\n\n    if (url_or_key.startsWith('https://docs.google.com/spreadsheets/')) {\n        if (url_or_key.match(/\\/pub\\?output=csv$/)) return url_or_key\n        let parsed = new URL(url_or_key)\n        let params = new URLSearchParams(parsed.search)\n        params.set('output', 'csv')\n        if (params.get('gid')) {\n            params.set('single', 'true')\n        }\n        parsed.search = `?${params.toString()}`\n        let base_path = parsed.pathname.substr(0, parsed.pathname.lastIndexOf('/'))\n        parsed.pathname = `${base_path}/pub`\n        return parsed.toString()\n    }\n    throw new TLError('invalid_url_err', url_or_key);\n}\n\n/**\n * Given a Google Sheets URL (or mere document ID), read the data and return\n * a Timeline JSON file suitable for instantiating a timeline.\n * \n * @param {string} url \n */\nexport async function readGoogleAsCSV(url, sheets_proxy) {\n\n    let rows = []\n\n    url = makeGoogleCSVURL(url)\n    let error = null;\n\n    await fetchCSV({\n        url: `${sheets_proxy}${url}`,\n    }).then(d => {\n        rows = d;\n    }).catch(error_json => {\n        if (error_json.proxy_err_code == 'response_not_csv') {\n            // throw new TLError('Timeline could not read the data for your timeline. Make sure you have published it to the web.')\n        }\n        // throw new TLError(error_json.message)\n    })\n\n    let timeline_config = { 'events': [], 'errors': [], 'warnings': [], 'eras': [] }\n\n    rows.forEach((row, i) => {\n        try {\n            if (!isEmptyObject(row)) {\n                let event = extractEventFromCSVObject(row)\n                handleRow(event, timeline_config)\n            }\n        } catch (e) {\n            if (e.constructor == TLError) {\n                timeline_config.errors.push(e);\n            } else {\n                if (e.message) {\n                    e = e.message;\n                }\n                let label = row['Headline'] || i\n                timeline_config.errors.push(e + `[${label}]`);\n            }\n        }\n    });\n    console.log(timeline_config);\n    return timeline_config\n}\n\nfunction handleRow(event, timeline_config) {\n    var row_type = 'event';\n    if (typeof(event.type) != 'undefined') {\n        row_type = event.type;\n        delete event.type;\n    }\n    if (row_type == 'title') {\n        if (!timeline_config.title) {\n            timeline_config.title = event;\n        } else {\n            timeline_config.warnings.push(\"Multiple title slides detected.\");\n            timeline_config.events.push(event);\n        }\n    } else if (row_type == 'era') {\n        timeline_config.eras.push(event);\n    } else {\n        timeline_config.events.push(event);\n    }\n}\n\nfunction extractEventFromCSVObject(orig_row) {\n\n    let row = {}\n    Object.keys(orig_row).forEach(k => {\n        row[k] = trim(orig_row[k]) // get rid of white-space and reduce all-blank cells to empty strings\n    })\n\n    var d = {\n        media: {\n            caption: row['Media Caption'] || '',\n            credit: row['Media Credit'] || '',\n            url: row['Media'] || '',\n            thumbnail: row['Media Thumbnail'] || ''\n        },\n        text: {\n            headline: row['Headline'] || '',\n            text: row['Text'] || ''\n        },\n        display_date: row['Display Date'] || '', // only in v3 but no problem\n        group: row['Group'] || row['Tag'] || '', // small diff between v1 and v3 sheets\n        background: interpretBackground(row['Background']), // only in v3 but no problem\n        type: row['Type'] || ''\n    }\n\n    if (Object.keys(row).includes('Start Date') || Object.keys(row).includes('End Date')) {\n        // V1 date handling\n        if (row['Start Date']) {\n            d.start_date = parseDate(row['Start Date'])\n        }\n        if (row['End Date']) {\n            d.end_date = parseDate(row['End Date'])\n        }\n    } else {\n        // V3 date handling\n        // every date must have at least a year to be valid.\n        if (row['Year']) {\n            d.start_date = {\n                year: clean_integer(row['Year']),\n                month: clean_integer(row['Month']) || '',\n                day: clean_integer(row['Day']) || ''\n            }\n        }\n        if (row['End Year']) {\n            d.end_date = {\n                year: clean_integer(row['End Year']) || '',\n                month: clean_integer(row['End Month']) || '',\n                day: clean_integer(row['End Day']) || ''\n            }\n        }\n\n        if (row['Time']) {\n            if (d.start_date) {\n                mergeData(d.start_date, parseTime(row['Time']));\n            } else {\n                throw new TLError(\"invalid_start_time_without_date\")\n            }\n        }\n\n        if (row['End Time']) {\n            if (d.end_date) {\n                mergeData(d.end_date, parseTime(row['End Time']));\n            } else {\n                throw new TLError(\"invalid_end_time_without_date\")\n            }\n        }\n\n        if (d.start_date && !validDateConfig(d.start_date)) {\n            throw new TLError(\"invalid_date_err\")\n        }\n\n        if (d.end_date && !validDateConfig(d.end_date)) {\n            throw new TLError(\"invalid_date_err\")\n        }\n\n\n    }\n\n    return d\n}\n"]},"metadata":{},"sourceType":"module"}