{"ast":null,"code":"import { isPlainObject, isArray, isSymbol } from 'is-what';\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n\nfunction assignProp(carry, key, newVal, originalObject) {\n  var propType = originalObject.propertyIsEnumerable(key) ? 'enumerable' : 'nonenumerable';\n  if (propType === 'enumerable') carry[key] = newVal;\n\n  if (propType === 'nonenumerable') {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nfunction mergeRecursively(origin, newComer, extensions) {\n  // work directly on newComer if its not an object\n  if (!isPlainObject(newComer)) {\n    // extend merge rules\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newComer = extend(origin, newComer);\n      });\n    }\n\n    return newComer;\n  } // define newObject to merge all values upon\n\n\n  var newObject = {};\n\n  if (isPlainObject(origin)) {\n    var props_1 = Object.getOwnPropertyNames(origin);\n    var symbols_1 = Object.getOwnPropertySymbols(origin);\n    newObject = __spreadArrays(props_1, symbols_1).reduce(function (carry, key) {\n      // @ts-ignore\n      var targetVal = origin[key];\n\n      if (!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) {\n        assignProp(carry, key, targetVal, origin);\n      }\n\n      return carry;\n    }, {});\n  }\n\n  var props = Object.getOwnPropertyNames(newComer);\n  var symbols = Object.getOwnPropertySymbols(newComer);\n\n  var result = __spreadArrays(props, symbols).reduce(function (carry, key) {\n    // re-define the origin and newComer as targetVal and newVal\n    var newVal = newComer[key];\n    var targetVal = isPlainObject(origin) ? // @ts-ignore\n    origin[key] : undefined; // extend merge rules\n\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newVal = extend(targetVal, newVal);\n      });\n    } // When newVal is an object do the merge recursively\n\n\n    if (targetVal !== undefined && isPlainObject(newVal)) {\n      newVal = mergeRecursively(targetVal, newVal, extensions);\n    }\n\n    assignProp(carry, key, newVal, newComer);\n    return carry;\n  }, newObject);\n\n  return result;\n}\n/**\n * Merge anything recursively.\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\n * Basic types overwrite objects or other basic types.\n *\n * @param {(IConfig | any)} origin\n * @param {...any[]} newComers\n * @returns the result\n */\n\n\nfunction merge(origin) {\n  var newComers = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    newComers[_i - 1] = arguments[_i];\n  }\n\n  var extensions = null;\n  var base = origin;\n\n  if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\n    base = {};\n    extensions = origin.extensions;\n  }\n\n  return newComers.reduce(function (result, newComer) {\n    return mergeRecursively(result, newComer, extensions);\n  }, base);\n}\n\nfunction concatArrays(originVal, newVal) {\n  if (isArray(originVal) && isArray(newVal)) {\n    // concat logic\n    return originVal.concat(newVal);\n  }\n\n  return newVal; // always return newVal as fallback!!\n}\n\nexport default merge;\nexport { concatArrays, merge };","map":{"version":3,"sources":["/Users/nanyang/AY20S2/CS9080/LookingGlass/lookingglass/node_modules/merge-anything/dist/index.esm.js"],"names":["isPlainObject","isArray","isSymbol","__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","assignProp","carry","key","newVal","originalObject","propType","propertyIsEnumerable","Object","defineProperty","value","enumerable","writable","configurable","mergeRecursively","origin","newComer","extensions","forEach","extend","newObject","props_1","getOwnPropertyNames","symbols_1","getOwnPropertySymbols","reduce","targetVal","includes","props","symbols","result","undefined","merge","newComers","_i","base","keys","concatArrays","originVal","concat"],"mappings":"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","sourcesContent":["import { isPlainObject, isArray, isSymbol } from 'is-what';\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\nfunction __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n}\n\nfunction assignProp(carry, key, newVal, originalObject) {\n    var propType = originalObject.propertyIsEnumerable(key)\n        ? 'enumerable'\n        : 'nonenumerable';\n    if (propType === 'enumerable')\n        carry[key] = newVal;\n    if (propType === 'nonenumerable') {\n        Object.defineProperty(carry, key, {\n            value: newVal,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        });\n    }\n}\nfunction mergeRecursively(origin, newComer, extensions) {\n    // work directly on newComer if its not an object\n    if (!isPlainObject(newComer)) {\n        // extend merge rules\n        if (extensions && isArray(extensions)) {\n            extensions.forEach(function (extend) {\n                newComer = extend(origin, newComer);\n            });\n        }\n        return newComer;\n    }\n    // define newObject to merge all values upon\n    var newObject = {};\n    if (isPlainObject(origin)) {\n        var props_1 = Object.getOwnPropertyNames(origin);\n        var symbols_1 = Object.getOwnPropertySymbols(origin);\n        newObject = __spreadArrays(props_1, symbols_1).reduce(function (carry, key) {\n            // @ts-ignore\n            var targetVal = origin[key];\n            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||\n                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {\n                assignProp(carry, key, targetVal, origin);\n            }\n            return carry;\n        }, {});\n    }\n    var props = Object.getOwnPropertyNames(newComer);\n    var symbols = Object.getOwnPropertySymbols(newComer);\n    var result = __spreadArrays(props, symbols).reduce(function (carry, key) {\n        // re-define the origin and newComer as targetVal and newVal\n        var newVal = newComer[key];\n        var targetVal = (isPlainObject(origin))\n            // @ts-ignore\n            ? origin[key]\n            : undefined;\n        // extend merge rules\n        if (extensions && isArray(extensions)) {\n            extensions.forEach(function (extend) {\n                newVal = extend(targetVal, newVal);\n            });\n        }\n        // When newVal is an object do the merge recursively\n        if (targetVal !== undefined && isPlainObject(newVal)) {\n            newVal = mergeRecursively(targetVal, newVal, extensions);\n        }\n        assignProp(carry, key, newVal, newComer);\n        return carry;\n    }, newObject);\n    return result;\n}\n/**\n * Merge anything recursively.\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\n * Basic types overwrite objects or other basic types.\n *\n * @param {(IConfig | any)} origin\n * @param {...any[]} newComers\n * @returns the result\n */\nfunction merge(origin) {\n    var newComers = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        newComers[_i - 1] = arguments[_i];\n    }\n    var extensions = null;\n    var base = origin;\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\n        base = {};\n        extensions = origin.extensions;\n    }\n    return newComers.reduce(function (result, newComer) {\n        return mergeRecursively(result, newComer, extensions);\n    }, base);\n}\n\nfunction concatArrays(originVal, newVal) {\n    if (isArray(originVal) && isArray(newVal)) {\n        // concat logic\n        return originVal.concat(newVal);\n    }\n    return newVal; // always return newVal as fallback!!\n}\n\nexport default merge;\nexport { concatArrays, merge };\n"]},"metadata":{},"sourceType":"module"}